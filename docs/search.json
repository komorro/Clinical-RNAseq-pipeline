[
  {
    "objectID": "RNAseq pipeline.html",
    "href": "RNAseq pipeline.html",
    "title": "RNAseq pipeline",
    "section": "",
    "text": "This is an analysis pipeline of a bulk RNAseq of samples collected from acute lymphoblastic leukemia (ALL) patients’ bone marrow (BM) and peripheral blood (PB) as a part of a undisclosed clinical trial. This analysis is performed on real-life clinical triala data, but as the data and results were not published yet, both count and clinical data were encrypted to some extent. Two of the variables in the encrypted clinical annotation file (Group and Event) were encrypted, as they are corresponding to relevant clinical features analyzed in the unpublished analysis.\n\n\n\n\n\n\nNote\n\n\n\nPart of this analysis is subsetting genes by their type (i.e. protein coding genes). The gene annotation process required the original names, so it can’t be reproduced using encrypted data provided with this analysis. If you would like to see how the gene annotation and encryption was performed, please expand the collapsed section below to see the R code used.\n\n\n\n\n\n\n\n\nEncryption process\n\n\n\n\n\n\n#load original count matrix from stored in RDS file\nraw.counts &lt;- readRDS('raw_counts.rds')\n\n#prepare list of unique sythetic gene names\nencrypt.genes&lt;- c()\nfor(x in 1:nrow(raw.counts)){\n  curnam&lt;-paste(sample(c(letters,LETTERS), 4, replace = T),collapse='')\n  while(curnam%in%encrypt.genes){\n    curnam2 &lt;-paste(sample(c(letters,LETTERS), 4, replace = T),collapse='')\n    assign(x = \"curnam\", value = curnam2)\n  }\n  encrypt.genes &lt;- append(encrypt.genes, curnam)\n}\n\n#Some of the gene names in raw counts file were duplicated, hence the duplicated original names were excluded\nencrypt.genes.dictionary &lt;- data.frame(actual = raw.counts$gene_name, encrypted = encrypt.genes) %&gt;%\n  filter(!duplicated(actual))\n\n#assign original gene names to rownames for easier subsetting/ordering\nrownames(encrypt.genes.dictionary) &lt;- encrypt.genes.dictionary$actual\n\n#Original count file contained duplicated gene names. \n#To reproduce this problem, synthetic gene names were also duplicated to correspond to original duplication pattern\nencrypt.genes.dictionary &lt;- encrypt.genes.dictionary[raw.counts$gene_name,]\n\n#annotation of genes using biomartr package\nall.genes.annot &lt;- biomartr::biomart( genes      = raw.counts$gene_name, # genes were retrieved using biomartr::getGenome()\n                                      mart       = \"ENSEMBL_MART_ENSEMBL\", # marts were selected with biomartr::getMarts()\n                                      dataset    = \"hsapiens_gene_ensembl\", # datasets were selected with biomartr::getDatasets()\n                                      attributes = c(\"gene_biotype\"), # attributes were selected with biomartr::getAttributes()\n                                      filters    = \"external_gene_name\") # specify what ID type was stored in the fasta file retrieved with biomartr::getGenome()\n\nannot.encryption.dictionary &lt;- encrypt.genes.dictionary[all.genes.annot$external_gene_name,]\n\n#check if all the actual names are the same and in the same order in the encryption data frame and target data frame\nall(annot.encryption.dictionary$actual == all.genes.annot$external_gene_name)\n\nall.genes.annot.encrypted &lt;- all.genes.annot\nall.genes.annot.encrypted$external_gene_name &lt;- annot.encryption.dictionary$encrypted\n\n#prepare list of synthetic sample IDs\nclin.data &lt;- read.csv('clin_data.csv') %&gt;% select(!1)\n\nanonymized.IDs &lt;- c()\nfor(x in 1:nrow(clin.data)){\n  anonymized.IDs&lt;-append(anonymized.IDs, paste0('Sample',x))\n}\n\nsamples.dictionary &lt;- data.frame(actual = clin.data$Sample.ID, encrypted = anonymized.IDs)\n\nclin.data.encrypted &lt;- clin.data %&gt;% \n  mutate(Sample.ID = samples.dictionary$encrypted)\n\n#encrypt gene names and sample names\nall(raw.counts$gene_name == encrypt.genes.dictionary$actual) #make sure gene names are in the same order\nraw.counts &lt;- raw.counts[,c('gene_name',samples.dictionary$actual)] #order the count data to match the sample IDs order\nall(colnames(raw.counts)[2:ncol(raw.counts)] == samples.dictionary$actual) #make sure sample names are in the same order\n\nraw.counts.encrypted &lt;- raw.counts[,c('gene_name',samples.dictionary$actual)]\ncolnames(raw.counts.encrypted)[2:ncol(raw.counts.encrypted)] &lt;-  samples.dictionary$encrypted\nraw.counts.encrypted$gene_name &lt;- encrypt.genes.dictionary$encrypted\n\n#write CSV files used in for the following analysis\nwrite.csv(all.genes.annot.encrypted, 'all_genes_annot_encrypted.csv')\nwrite.csv(raw.counts.encrypted, 'raw_counts_encrypted.csv')\nwrite.csv(clin.data.encrypted, 'clin_data_encrypted.csv')\n\n\n\n\n#Setup and data loading\nFirst, load libraries and set seed for the analysis, as some of the methods used in this pipeline rely on random numbers generation.\n\nlibrary(dplyr)\n\n#set seed\nset.seed(123)\n\nNow, let’s load the files relevant to the analysis (clinical annotation for samples, raw count matrix and list of genes annotated by their names).\n\nclin.data &lt;- read.csv('clin_data_encrypted.csv') %&gt;% select(!'X')\nraw.counts &lt;- read.csv('raw_counts_encrypted.csv') %&gt;% select(!'X')\nall.genes.annot &lt;- read.csv('all_genes_annot_encrypted.csv') %&gt;% select(!'X')\n\n\nRaw counts pre-processing\nFirst step of the analysis is checking the quality of raw counts. First, the genes are checked for any duplicated gene names:\n\nsum(duplicated(raw.counts$gene_name))\n\n[1] 1233\n\n\nand whether there are any non-expressed genes (genes with raw counts &lt; 10 in less than 3 samples):\n\nsum(!rowSums(raw.counts &gt; 10) &gt;= 3)\n\n[1] 11091\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe thresholds for counts and number of expressing samples were chosen arbitrarily, although they’re a good starting point, as suggested in the example DESeq2 pipeline. Those numbers might need to be modified for other analyses.\n\n\nDuplicated low/non expressed genes are not desired for downstream analyses of RNAseq, as they might introduce additional noise to the data and don’t provide much additional information. Hence, duplicated and non expressed genes were filtered from the dataset.\n\n#sort genes/rows from the ones with highest row-sum count\nraw.counts.clean &lt;- raw.counts[order(raw.counts$gene_name, -(rowMeans(raw.counts[,2:length(colnames(raw.counts))])) ), ]\n\n#keep only the first occurence of a gene (first has the highest total number of counts)\nraw.counts.clean &lt;- raw.counts.clean[!duplicated(raw.counts.clean$gene_name),]\n\n#replace rownames with gene_names\nrownames(raw.counts.clean)&lt;-NULL\nraw.counts.clean &lt;- raw.counts.clean %&gt;% tibble::column_to_rownames('gene_name')\n\n#check for genes with relevant expression (counts &gt; 10 in at least 3 samples, as recommended by DESeq2 pipeline for bulk RNAseq)\nrow.filter = rowSums(raw.counts.clean &gt; 10) &gt;= 3\n\n#filter out non-expressed genes and non-numeric columns\nraw.counts.clean &lt;- raw.counts.clean[row.filter,]\n\nThis leaves 46981 of expressed and unique genes, which were taken for the downstream analysis.\nThe genes were then annotated with gene types using biomartr package, to enable subsetting and analysis of genes, i.e. selecting protein coding genes only. Annotation was performed using biomartr package with ENSEMBL homo sapiens reference genome.\n\n\n\n\n\n\nCaution\n\n\n\nIn case of the encrypted files, annotation had to be performed prior to encryption of gene names, as it requires original gene names. For code used for annotation, refer to Encryption process section at the beginning of this document.\n\n\n#Samples characteristics and subsetting\nPrior to any analysis, data has to be subsetted to minimize the noise in the data. As the low/non-expressed and duplicated genes were already filtered out, next step would be sample exclusion and / or subsetting. First, clin.data was slightly modified and cleaned for easier subsetting.\n\nclin.data&lt;- clin.data %&gt;%\n  mutate(\n    #clean some discrepancies in naming of ALL subtypes\n    ALL.Molecular.Subtype=case_when(\n      ALL.Molecular.Subtype=='None of above' ~ 'None of the above',\n      TRUE ~ ALL.Molecular.Subtype\n    ),\n    #add column stating whether sample is diagnostic or relapsed\n    Isolation.Time=case_when(\n      grepl('Primary',Sample.Type)~'Primary',\n      grepl('Recurrent',Sample.Type)~'Relapsed'\n    ),\n    #unify naming of ALL type\n    Cell.of.Origin = if_else(Cell.of.Origin == 'T Cell ALL', 'T-ALL', 'B-ALL')) %&gt;% \n    #mutate the Sample.Type column to have information about tissue type only\n    mutate(Sample.Type=case_when(\n      grepl('Marrow',Sample.Type)~'Bone marrow',\n      grepl('Peripheral',Sample.Type)~'Peripheral blood'\n  ))"
  }
]